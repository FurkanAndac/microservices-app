<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Localhost Projects</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      padding: 0;
      position: relative;
    }

    h1 {
      color: #333;
    }

    ul {
      list-style: none;
      padding: 0;
    }

    li {
      margin-bottom: 10px;
    }

    a, button {
      display: inline-block;
      padding: 8px 16px;
      font-size: 14px;
      text-decoration: none;
      color: #fff;
      background-color: #3498db;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      text-align: center;
      margin-right: 10px; /* Add margin between buttons on desktop */
    }

    a:hover, button:hover {
      background-color: #2980b9;
    }

    #buttonContainer {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      /* Stack buttons in a column on small screens */
      flex-direction: column;
      align-items: flex-end; /* Align buttons to the right on small screens */
    }

    #buttonContainer a, #buttonContainer button {
      margin-bottom: 10px; /* Add space between buttons on mobile */
    }

    #deleteMicroserviceBtn {
      background-color: red;
      color: white;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }

    /* Styles for the toggle switch */
    .switch {
      display: inline-block;
      position: relative;
      height: 20px;
      width: 40px;
      margin-top: 10px; /* Add space between toggle switch and buttons on small screens */
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      -webkit-transition: .4s;
      transition: .4s;
      border-radius: 20px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      -webkit-transition: .4s;
      transition: .4s;
      border-radius: 50%;
    }

    .slider.round {
      border-radius: 34px;
    }

    .slider.round:before {
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: #4CAF50;
    }

    input:focus + .slider {
      box-shadow: 0 0 1px #4CAF50;
    }

    input:checked + .slider:before {
      -webkit-transform: translateX(20px);
      -ms-transform: translateX(20px);
      transform: translateX(20px);
    }

    #productionModeLabel {
      margin-left: 5px;
      color: #4CAF50;
    }

    /* Media query for desktop screens */
    @media (min-width: 768px) {
      #buttonContainer {
        flex-direction: row; /* Display buttons side by side on desktop */
      }

      #buttonContainer a, #buttonContainer button {
        margin-bottom: 0; /* Remove margin between buttons on desktop */
      }
    }
  </style>
</head>
<body>
  <div id="buttonContainer">
    <button id="addMicroservice" onclick="addMicroservice()">Add Microservice</button>
    <button id="deleteMicroserviceBtn" onclick="toggleDeleteMode()">Delete Microservice</button>
    <label class="switch">
        <input type="checkbox" id="productionToggle">
        <span class="slider round"></span>
      </label>
      <span id="productionModeLabel">Production Mode</span>
  </div> 

  <h1>Microservice Projects</h1>
  <ul id="projects-list"></ul>

  <script>
    const clientId = '65ae9f8a0a21b787ee3c9745'; // Replace with a valid client identifier
    const apiUrl = 'http://localhost:5000/api/microservices';

    let deleteMode = false; // Flag to indicate if in delete mode
    let productionMode = false; // Flag to indicate production mode

    // Function to handle microservice statuses received from backend
    const handleMicroserviceStatuses = async (microserviceLiveResults) => {
      const projectsList = document.getElementById('projects-list');

      microserviceLiveResults.forEach((result) => {
        const { url, microserviceLive } = result;
        const linkElements = document.querySelectorAll(`a[href="${url.href}"]`);

        linkElements.forEach((linkElement) => {
          if (microserviceLive) {
            // Set the color to indicate that the microservice is live
            linkElement.style.color = 'green';
          } else {
            // Set the color to indicate that the microservice is not live
            linkElement.style.color = 'red';
          }
        });
      });
    };

const toggleDeleteMode = () => {
  deleteMode = !deleteMode;
  const deleteMicroserviceBtn = document.getElementById('deleteMicroserviceBtn');
  deleteMicroserviceBtn.style.backgroundColor = deleteMode ? 'darkred' : 'red'; // Change button color based on deleteMode
  alert(`Delete mode is ${deleteMode ? 'on' : 'off'}. Click on a microservice to delete it.`);
};

// Example function for toggling production mode
const toggleProductionMode = () => {
  productionMode = !productionMode;
  const productionModeLabel = document.getElementById('productionModeLabel');
  productionModeLabel.style.color = productionMode ? '#4CAF50' : '#333'; // Change text color based on productionMode
  alert(`Production mode is ${productionMode ? 'on' : 'off'}.`);
  fetchMicroservices();
};

// Function to fetch frontend ping results
const fetchFrontendPing = () => {
  currentMicroservices = [];

  // Fetch frontend ping results and microservices concurrently
  Promise.all([
    fetch('http://localhost:5000/api/frontend-ping', { headers: { 'X-Client-Id': clientId } }),
    fetch('http://localhost:5000/api/microservices', { headers: { 'X-Client-Id': clientId } })
  ])
    .then(([pingResponse, microservicesResponse]) => Promise.all([pingResponse.json(), microservicesResponse.json()]))
    .then(([pingData, microservicesData]) => {
      console.log('Frontend Ping Results:', pingData);
      console.log('Microservices:', microservicesData);
      console.log('Production Mode:', productionMode);

      // Check if pingData is an array
      if (!pingData || !pingData.microserviceLiveResults || !Array.isArray(pingData.microserviceLiveResults)) {
        console.error('Error: Invalid frontend ping results structure.');
        console.error('Received data:', pingData);
        return;
      }

     // Filter and add microservices to currentMicroservices based on production mode
microservicesData.forEach(element => {
  // Check if the microservice's production mode matches the desired mode
  if (element.production === productionMode) {
    currentMicroservices.push(element);
  }
});

console.log('Current Microservices:', currentMicroservices);

      console.log('Current Microservices:', currentMicroservices);

      // Iterate through each microservice result
pingData.microserviceLiveResults.forEach(async (result, index) => {
  let currentMicroservice = currentMicroservices.find(microservice => microservice.url === result.url);

  console.log('result:', result);
  console.log('result.url:', result.url);
  console.log('currentMicroservice:', currentMicroservice);

  let buttonIndex = index + 1;

  // Skip the index if currentMicroservice is undefined
  if (!currentMicroservice) {
    console.warn(`Skipping index ${buttonIndex} because currentMicroservice is undefined.`);
    return;
  }

  // Create a selector based on microserviceId
  const buttonSelector = `#projects-list .microservice-item[data-id="${currentMicroservice._id}"]`;

  // Find the button corresponding to the microservice
  const button = document.querySelector(buttonSelector);

  // Check if the button is found
  if (button) {
    // Check if the microservice is live
    const microserviceLive = result.microserviceLive;

    // Change button color based on microserviceLive value
    button.style.backgroundColor = microserviceLive ? 'green' : 'red';
    button.style.color = 'white'; // Adjust text color as needed

    // Use microserviceId as needed
    const microserviceId = currentMicroservice._id;
    console.log('Microservice ID:', microserviceId);
  } else {
    console.error(`Button not found for microservice with _id ${currentMicroservice._id}.`);
  }
});


    })
    .catch(error => {
      console.error('Error fetching data:', error);
      alert('Error fetching data. Check the console for details.');
    });
};

// Call fetchFrontendPing every 15 seconds
setInterval(fetchFrontendPing, 15000);


    // Attach event listener to the toggle switch
    document.getElementById('productionToggle').addEventListener('change', toggleProductionMode);

    const initiateFrontendPing = () => {
  setInterval(async () => {
    try {
      // Assume microserviceLive is a boolean representing the current status
      const microserviceLive = true; // Replace with your actual logic to determine the status

      const response = await fetch('http://localhost:5000/api/frontend-ping', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Client-Id': clientId,
        },
        body: JSON.stringify({ microserviceLive }),
      });
      console.log("test: "+response.status)
      if (!response.ok) {
        throw new Error(`Failed to ping frontend: ${response.statusText}`);
      }

      const responseData = await response.json();
      console.log('Received response from frontend ping:', responseData);
    } catch (error) {
      console.error('Error pinging frontend:', error.message);
    }
  }, 15000); // 15 seconds interval
};

// Example usage:
// initiateFrontendPing();

//     const checkButtonStatus = async () => {
//   console.log('Checking button status...');

//   try {
//     const response = await fetch('http://localhost:5000/api/microservice-response', {
//       headers: { 'X-Client-Id': clientId },
//     });
//     const data = await response.json();
//     console.log(data);

//     const buttonsInMicroservices = document.querySelectorAll('#projects-list .microservice-item');

//     buttonsInMicroservices.forEach(async (button) => {
//       const linkElement = button.querySelector('a');
//       if (!linkElement) {
//         console.error('Link element not found.');
//         return;
//       }

//       const url = linkElement.getAttribute('href');
//       const matchingResponse = data.find((item) => item.url.includes(url));
//       console.log(url)

//       if (matchingResponse && matchingResponse.responseText !== '') {
//         // Set button color to blue if responseText is not empty
//         button.style.backgroundColor = 'blue';
//         button.style.color = 'white';
//       } else {
//         // Set button color to red if responseText is empty or ping fails
//         try {
//           const pingResponse = await fetch(url, { method: 'HEAD', mode: 'no-cors' });
//           if (!pingResponse.ok) {
//             button.style.backgroundColor = 'red';
//             button.style.color = 'white';
//           } else {
//             // Set to default color if ping is successful
//             button.style.backgroundColor = '#3498db';
//             button.style.color = 'white';
//           }
//         } catch (error) {
//           // Error in ping
//           console.error(`Error pinging microservice at ${url}:`, error);
//           button.style.backgroundColor = 'red';
//           button.style.color = 'white';
//         }
//       }
//     });
//   } catch (error) {
//     console.error('Error fetching button status:', error);
//   }
// };

    const fetchMicroservices = () => {
  // Fetch the list of microservices and dynamically create links
  fetch(`${apiUrl}?production=${productionMode}`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      'X-Client-ID': clientId,
    },
  })
    .then(response => response.json())
    .then(data => {
        const projectsList = document.getElementById('projects-list');
projectsList.innerHTML = ''; // Clear existing microservices

data.forEach(microservice => {
  console.log(microservice);
  // Check if the microservice should be shown based on the production mode toggle
  if (microservice.production === productionMode) {
    const listItem = document.createElement('li');
    const link = document.createElement('a');

    link.textContent = microservice.name;
    link.href = microservice.url.startsWith('http') || microservice.url.startsWith('https')
  ? microservice.url
  : 'http://' + microservice.url;
      console.log(link.href);

    link.setAttribute('data-id', microservice._id);
    link.classList.add('microservice-item');

    listItem.classList.add('microservice-item');

    listItem.appendChild(link);
    projectsList.appendChild(listItem);
  }
});

    //   checkButtonStatus();
      console.log('fetchMicroservices executed'); // Add this line for debugging

      console.log(data);
    })
    .catch(error => {
      console.error('Error:', error);
      alert('Error fetching microservices. Check the console for details.');
    });
};
fetchMicroservices();

// Fetch the microservice statuses periodically
const fetchMicroserviceStatuses = async () => {
      try {
        const response = await fetch('http://localhost:5000/api/frontend-ping', {
          headers: { 'X-Client-Id': clientId },
        });
        const data = await response.json();

        // Handle the microservice statuses received from the backend
        handleMicroserviceStatuses(data.microserviceLiveResults);
      } catch (error) {
        console.error('Error fetching microservice statuses:', error);
      }
    };

    // Call the function when the page loads
    fetchMicroserviceStatuses();
    setInterval(fetchMicroserviceStatuses, 15000);

document.addEventListener('click', (event) => {
      const clickedElement = event.target;

      console.log('Clicked element:', clickedElement);
      console.log('Class names:', clickedElement.classList);

      if (deleteMode && clickedElement.classList.contains('microservice-item')) {
        console.log('Entered if statement');
        event.preventDefault(); // Prevent the default behavior
        const microserviceId = clickedElement.getAttribute('data-id');

        console.log('Microservice ID:', microserviceId);

        // Send a DELETE request to the backend API
        fetch(`http://localhost:5000/api/microservices/${microserviceId}`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
            'X-Client-ID': clientId,
          },
        })
          .then(response => response.json())
          .then(data => {
            console.log(data.message);
            // Optionally, update the UI to remove the deleted microservice
            clickedElement.remove();
          })
          .catch(error => {
            console.error('Error deleting microservice:', error);
            alert('Error deleting microservice. Check the console for details.');
          });
      }
    });

    // Fetch microservices initially
    fetchMicroservices();

    const addMicroservice = () => {
  const name = prompt('Enter microservice name:');
  let url = prompt('Enter microservice URL:');

  // Check if the URL starts with 'http://' or 'https://'
  if (!url.startsWith('http://') && !url.startsWith('https://')) {
    // If it doesn't start with either, add 'http://'
    url = 'http://' + url;
  }

  if (name && url) {
    const postData = {
      name: name,
      url: url,
      client: clientId, // Include the client ID
      production: productionMode, // Get the current state of the productionMode
    };

    console.log('Sending POST request with data:', postData);

    fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Client-ID': clientId,
      },
      body: JSON.stringify(postData),
    })
      .then(response => response.json())
      .then(data => {
        // Handle the response data from the backend
        console.log("test1: "+Object.entries(data));
        alert('Microservice added successfully. Check the console for details.');

        // Refresh microservices list after adding a new microservice
        fetchMicroservices();
      })
      .catch(error => {
        console.error('Error:', error);
        alert('Error adding microservice. Check the console for details.');
      });
  }
};



// ...

// Call the function when the page loads
// checkButtonStatus();
// setInterval(checkButtonStatus, 15000);

    // Fetch the list of projects and dynamically create links
    // fetch('/api/projects')
    //   .then(response => response.json())
    //   .then(projects => {
    //     const projectsList = document.getElementById('projects-list');

    //     projects.forEach(project => {
    //       const listItem = document.createElement('li');
    //       const link = document.createElement('a');

    //       link.textContent = project.name;
    //       link.href = project.url;

    //       listItem.appendChild(link);
    //       projectsList.appendChild(listItem);
    //     });
    //   })
    //   .catch(error => console.error('Error fetching projects:', error));


    //   fetch(apiUrl + `?production=${!productionMode}`,{
    //     method: 'GET',
    //     headers: {
    //       'Content-Type': 'application/json',
    //       'X-Client-ID': clientId,
    //     },
    //   })
    //     .then(response => response.json())
    //     .then(data => {
    //         const projectsList = document.getElementById('projects-list'); 
    //         projectsList.innerHTML = ''; // Clear existing microservices

    //         data.forEach(microservice => {
    //             const listItem = document.createElement('li');
    //             const link = document.createElement('a');

    //             link.textContent = microservice.name;
    //             link.href = microservice.url;
    //             link.setAttribute('data-id', microservice._id);
    //             link.classList.add('microservice-item');

    //             listItem.classList.add('microservice-item');

    //             listItem.appendChild(link);
    //             projectsList.appendChild(listItem);
    //         })
    //       // Handle the response data from the backend
    //       console.log(data);
    //     //   alert('Collections retrieved successfully. Check the console for details.');
    //     })
    //     .catch(error => {
    //       console.error('Error:', error);
    //       alert('Error fetching collections. Check the console for details.');
    //     });

    fetchFrontendPing();

  </script>
</body>
</html>
